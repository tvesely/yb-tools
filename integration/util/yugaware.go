package util

import (
	"bytes"
	"context"
	"database/sql"
	"fmt"
	"strconv"
	"time"

	"github.com/blang/vfs"
	"github.com/blang/vfs/memfs"
	"github.com/go-logr/logr"
	. "github.com/icza/gox/gox"
	. "github.com/onsi/gomega"
	"github.com/yugabyte/gocql"
	"github.com/yugabyte/yb-tools/yugatool/api/yb/common"
	"github.com/yugabyte/yb-tools/yugaware-client/cmd"
	"github.com/yugabyte/yb-tools/yugaware-client/pkg/client"
	"github.com/yugabyte/yb-tools/yugaware-client/pkg/client/swagger/client/session_management"
	"github.com/yugabyte/yb-tools/yugaware-client/pkg/client/swagger/models"
)

type YWTestContext struct {
	*client.YugawareClient

	Hostname             string
	DialTimeout          int
	SkipHostVerification bool
	CACert               string
	ClientCert           string
	ClientKey            string
	APIToken             string
	Fs                   vfs.Filesystem
}

func NewYugawareTestContext(ctx context.Context, logger logr.Logger, hostname string, dialTimeout int, skipHostVerification bool, cacert, clientCert, clientKey, apiToken string) *YWTestContext {
	ywclient, err := client.New(ctx, logger, hostname).
		TLSOptions(&client.TLSOptions{
			SkipHostVerification: skipHostVerification,
			CaCertPath:           cacert,
			CertPath:             clientCert,
			KeyPath:              clientKey,
		}).APIToken(apiToken).
		TimeoutSeconds(dialTimeout).
		Connect()
	Expect(err).NotTo(HaveOccurred())

	return &YWTestContext{
		YugawareClient:       ywclient,
		Hostname:             hostname,
		DialTimeout:          dialTimeout,
		SkipHostVerification: skipHostVerification,
		CACert:               cacert,
		ClientCert:           clientCert,
		ClientKey:            clientKey,
		APIToken:             apiToken,
		Fs:                   memfs.Create(),
	}
}

func (c *YWTestContext) CreateUniverseIfNotExists(universeName, provider, instanceType string, withTLS bool, regions ...string) *models.UniverseResp {
	universe := c.GetUniverse(universeName)
	if universe == nil {
		opts := []string{"universe", "create", universeName, "--provider", provider, "--instance-type", instanceType, "--wait"}
		for _, region := range regions {
			opts = append(opts, "--regions", region)
		}

		if withTLS {
			opts = append(opts, "--enable-encryption")
		}

		_, err := c.RunYugawareCommand(opts...)
		Expect(err).NotTo(HaveOccurred())

		universe = c.GetUniverse(universeName)
	}
	Expect(universe).NotTo(BeNil())
	return universe
}

func (c *YWTestContext) CleanupUniverse(universeName string) {
	universe := c.GetUniverse(universeName)
	if universe != nil {
		_, err := c.RunYugawareCommand("universe", "delete", universeName, "--wait", "--approve", "--delete-backups", "--force")

		Expect(err).NotTo(HaveOccurred())
	}
}

func (c *YWTestContext) GetUniverse(universeName string) *models.UniverseResp {
	universe, err := c.GetUniverseByIdentifier(universeName)
	Expect(err).NotTo(HaveOccurred())
	return universe
}

func (c *YWTestContext) RunYugawareCommand(args ...string) ([]byte, error) {
	ywCommand := cmd.RootInit(c.Fs)
	args = append(args, "--hostname", c.Hostname, "--dialtimeout", strconv.Itoa(c.DialTimeout), "--api-token", c.APIToken)

	if c.SkipHostVerification {
		args = append(args, "--skiphostverification")
	}

	if c.CACert != "" {
		args = append(args, "--cacert", c.CACert)
	}

	if c.ClientCert != "" {
		args = append(args, "--client-cert", c.ClientCert)
	}

	if c.ClientKey != "" {
		args = append(args, "--client-key", c.ClientKey)
	}

	buf := new(bytes.Buffer)
	ywCommand.SetOut(buf)
	ywCommand.SetErr(buf)

	ywCommand.SetArgs(args)

	err := ywCommand.Execute()
	return buf.Bytes(), err
}

func (c *YWTestContext) GetMasterAddresses(universeName string) []*common.HostPortPB {
	universe := c.GetUniverse(universeName)

	var masters []*common.HostPortPB
	for _, node := range universe.UniverseDetails.NodeDetailsSet {
		if node.IsMaster {
			masters = append(masters, &common.HostPortPB{Host: &node.CloudInfo.PrivateIP, Port: NewUint32(uint32(node.MasterRPCPort))})
		}
	}

	return masters
}

func (c *YWTestContext) CreateYugatoolContext(universeName string) *YugatoolTestContext {
	universe := c.GetUniverse(universeName)

	Expect(len(universe.UniverseDetails.Clusters)).To(BeNumerically(">", 0))
	userIntent := universe.UniverseDetails.Clusters[0].UserIntent

	useEncryption := userIntent.EnableNodeToNodeEncrypt

	skipHostVerification := false

	var cacert []byte
	var err error
	if useEncryption {
		// TODO: Work around for PLAT-3408 - the certificate generated by platform for kubernetes is not valid
		if userIntent.ProviderType == "kubernetes" {
			skipHostVerification = true
		}

		cacert, err = c.RunYugawareCommand("certificate", "get-root", universe.UniverseDetails.RootCA.String())
		Expect(err).NotTo(HaveOccurred())
		Expect(len(cacert)).To(BeNumerically(">", 0))
	}

	// TODO: Should test with the clientCert or clientKey
	return NewYugatoolTestContext(c.Log, universe, c.GetMasterAddresses(universeName), int64(c.DialTimeout), cacert, nil, nil, skipHostVerification)
}

func (c *YWTestContext) DumpYugawareLogs() {
	params := session_management.NewGetLogsParams().
		WithMaxLines(int32(400))

	response, err := c.PlatformAPIs.SessionManagement.GetLogs(params, c.SwaggerAuth)
	if err == nil {
		logLines := response.GetPayload().Lines

		fmt.Println("===============================================================")
		fmt.Println("                       Yugaware Logs")
		fmt.Println("===============================================================")
		fmt.Println()

		for _, line := range logLines {
			fmt.Println(line)
		}

		fmt.Println()
	}
}

func (c *YWTestContext) YCQLConnection(universeName string) *gocql.Session {
	universe := c.GetUniverse(universeName)
	for _, server := range universe.UniverseDetails.NodeDetailsSet {
		if server.IsTserver {
			if server.IsYqlServer {
				ycqlClient := gocql.NewCluster(server.CloudInfo.PrivateIP)

				if universe.UniverseDetails.Clusters[0].UserIntent.EnableClientToNodeEncrypt {
					ycqlClient.SslOpts = &gocql.SslOptions{
						EnableHostVerification: false,
					}
				}

				ycqlClient.Timeout = time.Minute
				ycqlClient.PoolConfig.HostSelectionPolicy = gocql.TokenAwareHostPolicy(gocql.RoundRobinHostPolicy())

				session, err := ycqlClient.CreateSession()
				if err != nil {
					continue
				}

				return session
			}
			break
		}
	}

	panic("Could not connect to any YCQL host")
}

func (c *YWTestContext) YSQLConnection(universeName string, database string) *sql.DB {
	universe := c.GetUniverse(universeName)
	var psqlInfo string
	for _, server := range universe.UniverseDetails.NodeDetailsSet {
		if server.IsTserver {
			sslMode := "disable"
			if universe.UniverseDetails.Clusters[0].UserIntent.EnableClientToNodeEncrypt {
				sslMode = "require"
			}

			psqlInfo = fmt.Sprintf("host=%s port=%d user=%s dbname=%s sslmode=%s",
				server.CloudInfo.PrivateIP, server.YsqlServerRPCPort, "yugabyte", database, sslMode)
			break
		}
	}
	db, err := sql.Open("postgres", psqlInfo)
	Expect(err).NotTo(HaveOccurred())
	return db
}

func (c *YWTestContext) CreateYSQLDatabase(universe string, database string) {
	con := c.YSQLConnection(universe, "yugabyte")
	defer con.Close()

	r, err := con.Query("select true from pg_database where datname = $1", database)
	Expect(err).NotTo(HaveOccurred())

	var exists bool
	for r.Next() {
		err = r.Scan(&exists)
		Expect(err).NotTo(HaveOccurred())
	}

	if !exists {
		_, err := con.Exec(fmt.Sprintf("create database %s", database))
		Expect(err).NotTo(HaveOccurred())
	}
}

func (c *YWTestContext) DropYSQLDatabase(universe string, database string) {
	con := c.YSQLConnection(universe, "yugabyte")
	defer con.Close()

	_, err := con.Exec(fmt.Sprintf("drop database %s", database))
	Expect(err).NotTo(HaveOccurred())
}
