// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BackupResp backup resp
//
// swagger:model BackupResp
type BackupResp struct {

	// backup type
	// Required: true
	// Enum: [YQL_TABLE_TYPE REDIS_TABLE_TYPE PGSQL_TABLE_TYPE TRANSACTION_STATUS_TABLE_TYPE]
	BackupType *string `json:"backupType"`

	// backup UUID
	// Required: true
	// Format: uuid
	BackupUUID *strfmt.UUID `json:"backupUUID"`

	// completion time
	// Required: true
	// Format: date-time
	CompletionTime *strfmt.DateTime `json:"completionTime"`

	// create time
	// Required: true
	// Format: date-time
	CreateTime *strfmt.DateTime `json:"createTime"`

	// customer UUID
	// Required: true
	// Format: uuid
	CustomerUUID *strfmt.UUID `json:"customerUUID"`

	// expiry time
	// Required: true
	// Format: date-time
	ExpiryTime *strfmt.DateTime `json:"expiryTime"`

	// is full backup
	// Required: true
	IsFullBackup *bool `json:"isFullBackup"`

	// is storage config present
	// Required: true
	IsStorageConfigPresent *bool `json:"isStorageConfigPresent"`

	// is universe present
	// Required: true
	IsUniversePresent *bool `json:"isUniversePresent"`

	// kms config UUID
	// Required: true
	// Format: uuid
	KmsConfigUUID *strfmt.UUID `json:"kmsConfigUUID"`

	// on demand
	// Required: true
	OnDemand *bool `json:"onDemand"`

	// response list
	// Required: true
	// Unique: true
	ResponseList []*KeyspaceTablesList `json:"responseList"`

	// schedule UUID
	// Required: true
	// Format: uuid
	ScheduleUUID *strfmt.UUID `json:"scheduleUUID"`

	// sse
	// Required: true
	Sse *bool `json:"sse"`

	// state
	// Required: true
	// Enum: [InProgress Completed Failed Deleted Skipped FailedToDelete Stopped DeleteInProgress QueuedForDeletion]
	State *string `json:"state"`

	// storage config type
	// Required: true
	// Enum: [S3 NFS AZ GCS FILE]
	StorageConfigType *string `json:"storageConfigType"`

	// storage config UUID
	// Required: true
	// Format: uuid
	StorageConfigUUID *strfmt.UUID `json:"storageConfigUUID"`

	// task UUID
	// Required: true
	// Format: uuid
	TaskUUID *strfmt.UUID `json:"taskUUID"`

	// total backup size in bytes
	// Required: true
	TotalBackupSizeInBytes *int64 `json:"totalBackupSizeInBytes"`

	// universe name
	// Required: true
	UniverseName *string `json:"universeName"`

	// universe UUID
	// Required: true
	// Format: uuid
	UniverseUUID *strfmt.UUID `json:"universeUUID"`

	// update time
	// Required: true
	// Format: date-time
	UpdateTime *strfmt.DateTime `json:"updateTime"`
}

// Validate validates this backup resp
func (m *BackupResp) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBackupType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBackupUUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompletionTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomerUUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExpiryTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsFullBackup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsStorageConfigPresent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsUniversePresent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKmsConfigUUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOnDemand(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResponseList(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScheduleUUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSse(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageConfigType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageConfigUUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaskUUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalBackupSizeInBytes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUniverseName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUniverseUUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdateTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var backupRespTypeBackupTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["YQL_TABLE_TYPE","REDIS_TABLE_TYPE","PGSQL_TABLE_TYPE","TRANSACTION_STATUS_TABLE_TYPE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		backupRespTypeBackupTypePropEnum = append(backupRespTypeBackupTypePropEnum, v)
	}
}

const (

	// BackupRespBackupTypeYQLTABLETYPE captures enum value "YQL_TABLE_TYPE"
	BackupRespBackupTypeYQLTABLETYPE string = "YQL_TABLE_TYPE"

	// BackupRespBackupTypeREDISTABLETYPE captures enum value "REDIS_TABLE_TYPE"
	BackupRespBackupTypeREDISTABLETYPE string = "REDIS_TABLE_TYPE"

	// BackupRespBackupTypePGSQLTABLETYPE captures enum value "PGSQL_TABLE_TYPE"
	BackupRespBackupTypePGSQLTABLETYPE string = "PGSQL_TABLE_TYPE"

	// BackupRespBackupTypeTRANSACTIONSTATUSTABLETYPE captures enum value "TRANSACTION_STATUS_TABLE_TYPE"
	BackupRespBackupTypeTRANSACTIONSTATUSTABLETYPE string = "TRANSACTION_STATUS_TABLE_TYPE"
)

// prop value enum
func (m *BackupResp) validateBackupTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, backupRespTypeBackupTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *BackupResp) validateBackupType(formats strfmt.Registry) error {

	if err := validate.Required("backupType", "body", m.BackupType); err != nil {
		return err
	}

	// value enum
	if err := m.validateBackupTypeEnum("backupType", "body", *m.BackupType); err != nil {
		return err
	}

	return nil
}

func (m *BackupResp) validateBackupUUID(formats strfmt.Registry) error {

	if err := validate.Required("backupUUID", "body", m.BackupUUID); err != nil {
		return err
	}

	if err := validate.FormatOf("backupUUID", "body", "uuid", m.BackupUUID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *BackupResp) validateCompletionTime(formats strfmt.Registry) error {

	if err := validate.Required("completionTime", "body", m.CompletionTime); err != nil {
		return err
	}

	if err := validate.FormatOf("completionTime", "body", "date-time", m.CompletionTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *BackupResp) validateCreateTime(formats strfmt.Registry) error {

	if err := validate.Required("createTime", "body", m.CreateTime); err != nil {
		return err
	}

	if err := validate.FormatOf("createTime", "body", "date-time", m.CreateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *BackupResp) validateCustomerUUID(formats strfmt.Registry) error {

	if err := validate.Required("customerUUID", "body", m.CustomerUUID); err != nil {
		return err
	}

	if err := validate.FormatOf("customerUUID", "body", "uuid", m.CustomerUUID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *BackupResp) validateExpiryTime(formats strfmt.Registry) error {

	if err := validate.Required("expiryTime", "body", m.ExpiryTime); err != nil {
		return err
	}

	if err := validate.FormatOf("expiryTime", "body", "date-time", m.ExpiryTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *BackupResp) validateIsFullBackup(formats strfmt.Registry) error {

	if err := validate.Required("isFullBackup", "body", m.IsFullBackup); err != nil {
		return err
	}

	return nil
}

func (m *BackupResp) validateIsStorageConfigPresent(formats strfmt.Registry) error {

	if err := validate.Required("isStorageConfigPresent", "body", m.IsStorageConfigPresent); err != nil {
		return err
	}

	return nil
}

func (m *BackupResp) validateIsUniversePresent(formats strfmt.Registry) error {

	if err := validate.Required("isUniversePresent", "body", m.IsUniversePresent); err != nil {
		return err
	}

	return nil
}

func (m *BackupResp) validateKmsConfigUUID(formats strfmt.Registry) error {

	if err := validate.Required("kmsConfigUUID", "body", m.KmsConfigUUID); err != nil {
		return err
	}

	if err := validate.FormatOf("kmsConfigUUID", "body", "uuid", m.KmsConfigUUID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *BackupResp) validateOnDemand(formats strfmt.Registry) error {

	if err := validate.Required("onDemand", "body", m.OnDemand); err != nil {
		return err
	}

	return nil
}

func (m *BackupResp) validateResponseList(formats strfmt.Registry) error {

	if err := validate.Required("responseList", "body", m.ResponseList); err != nil {
		return err
	}

	if err := validate.UniqueItems("responseList", "body", m.ResponseList); err != nil {
		return err
	}

	for i := 0; i < len(m.ResponseList); i++ {
		if swag.IsZero(m.ResponseList[i]) { // not required
			continue
		}

		if m.ResponseList[i] != nil {
			if err := m.ResponseList[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("responseList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("responseList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupResp) validateScheduleUUID(formats strfmt.Registry) error {

	if err := validate.Required("scheduleUUID", "body", m.ScheduleUUID); err != nil {
		return err
	}

	if err := validate.FormatOf("scheduleUUID", "body", "uuid", m.ScheduleUUID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *BackupResp) validateSse(formats strfmt.Registry) error {

	if err := validate.Required("sse", "body", m.Sse); err != nil {
		return err
	}

	return nil
}

var backupRespTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["InProgress","Completed","Failed","Deleted","Skipped","FailedToDelete","Stopped","DeleteInProgress","QueuedForDeletion"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		backupRespTypeStatePropEnum = append(backupRespTypeStatePropEnum, v)
	}
}

const (

	// BackupRespStateInProgress captures enum value "InProgress"
	BackupRespStateInProgress string = "InProgress"

	// BackupRespStateCompleted captures enum value "Completed"
	BackupRespStateCompleted string = "Completed"

	// BackupRespStateFailed captures enum value "Failed"
	BackupRespStateFailed string = "Failed"

	// BackupRespStateDeleted captures enum value "Deleted"
	BackupRespStateDeleted string = "Deleted"

	// BackupRespStateSkipped captures enum value "Skipped"
	BackupRespStateSkipped string = "Skipped"

	// BackupRespStateFailedToDelete captures enum value "FailedToDelete"
	BackupRespStateFailedToDelete string = "FailedToDelete"

	// BackupRespStateStopped captures enum value "Stopped"
	BackupRespStateStopped string = "Stopped"

	// BackupRespStateDeleteInProgress captures enum value "DeleteInProgress"
	BackupRespStateDeleteInProgress string = "DeleteInProgress"

	// BackupRespStateQueuedForDeletion captures enum value "QueuedForDeletion"
	BackupRespStateQueuedForDeletion string = "QueuedForDeletion"
)

// prop value enum
func (m *BackupResp) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, backupRespTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *BackupResp) validateState(formats strfmt.Registry) error {

	if err := validate.Required("state", "body", m.State); err != nil {
		return err
	}

	// value enum
	if err := m.validateStateEnum("state", "body", *m.State); err != nil {
		return err
	}

	return nil
}

var backupRespTypeStorageConfigTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["S3","NFS","AZ","GCS","FILE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		backupRespTypeStorageConfigTypePropEnum = append(backupRespTypeStorageConfigTypePropEnum, v)
	}
}

const (

	// BackupRespStorageConfigTypeS3 captures enum value "S3"
	BackupRespStorageConfigTypeS3 string = "S3"

	// BackupRespStorageConfigTypeNFS captures enum value "NFS"
	BackupRespStorageConfigTypeNFS string = "NFS"

	// BackupRespStorageConfigTypeAZ captures enum value "AZ"
	BackupRespStorageConfigTypeAZ string = "AZ"

	// BackupRespStorageConfigTypeGCS captures enum value "GCS"
	BackupRespStorageConfigTypeGCS string = "GCS"

	// BackupRespStorageConfigTypeFILE captures enum value "FILE"
	BackupRespStorageConfigTypeFILE string = "FILE"
)

// prop value enum
func (m *BackupResp) validateStorageConfigTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, backupRespTypeStorageConfigTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *BackupResp) validateStorageConfigType(formats strfmt.Registry) error {

	if err := validate.Required("storageConfigType", "body", m.StorageConfigType); err != nil {
		return err
	}

	// value enum
	if err := m.validateStorageConfigTypeEnum("storageConfigType", "body", *m.StorageConfigType); err != nil {
		return err
	}

	return nil
}

func (m *BackupResp) validateStorageConfigUUID(formats strfmt.Registry) error {

	if err := validate.Required("storageConfigUUID", "body", m.StorageConfigUUID); err != nil {
		return err
	}

	if err := validate.FormatOf("storageConfigUUID", "body", "uuid", m.StorageConfigUUID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *BackupResp) validateTaskUUID(formats strfmt.Registry) error {

	if err := validate.Required("taskUUID", "body", m.TaskUUID); err != nil {
		return err
	}

	if err := validate.FormatOf("taskUUID", "body", "uuid", m.TaskUUID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *BackupResp) validateTotalBackupSizeInBytes(formats strfmt.Registry) error {

	if err := validate.Required("totalBackupSizeInBytes", "body", m.TotalBackupSizeInBytes); err != nil {
		return err
	}

	return nil
}

func (m *BackupResp) validateUniverseName(formats strfmt.Registry) error {

	if err := validate.Required("universeName", "body", m.UniverseName); err != nil {
		return err
	}

	return nil
}

func (m *BackupResp) validateUniverseUUID(formats strfmt.Registry) error {

	if err := validate.Required("universeUUID", "body", m.UniverseUUID); err != nil {
		return err
	}

	if err := validate.FormatOf("universeUUID", "body", "uuid", m.UniverseUUID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *BackupResp) validateUpdateTime(formats strfmt.Registry) error {

	if err := validate.Required("updateTime", "body", m.UpdateTime); err != nil {
		return err
	}

	if err := validate.FormatOf("updateTime", "body", "date-time", m.UpdateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this backup resp based on the context it is used
func (m *BackupResp) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateResponseList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BackupResp) contextValidateResponseList(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ResponseList); i++ {

		if m.ResponseList[i] != nil {
			if err := m.ResponseList[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("responseList" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("responseList" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *BackupResp) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BackupResp) UnmarshalBinary(b []byte) error {
	var res BackupResp
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
