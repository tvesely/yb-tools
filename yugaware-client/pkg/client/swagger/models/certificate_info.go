// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CertificateInfo SSL certificate used by the universe
//
// swagger:model CertificateInfo
type CertificateInfo struct {

	// Type of the certificate
	// Example: SelfSigned
	// Enum: [SelfSigned CustomCertHostPath CustomServerCert HashicorpVault]
	CertType string `json:"certType,omitempty"`

	// Certificate path
	// Example: /opt/yugaware/certs/.../ca.root.cert
	Certificate string `json:"certificate,omitempty"`

	// The certificate file's checksum
	// Read Only: true
	Checksum string `json:"checksum,omitempty"`

	// custom cert path params
	// Required: true
	CustomCertPathParams *CustomCertInfo `json:"customCertPathParams"`

	// custom h c p k i cert info
	// Required: true
	CustomHCPKICertInfo *HashicorpVaultConfigParams `json:"customHCPKICertInfo"`

	// custom server cert info
	// Required: true
	CustomServerCertInfo *CustomServerCertInfo `json:"customServerCertInfo"`

	// Customer UUID of the backup which it belongs to
	// Format: uuid
	CustomerUUID strfmt.UUID `json:"customerUUID,omitempty"`

	// The certificate's expiry date
	// Format: date-time
	ExpiryDate strfmt.DateTime `json:"expiryDate,omitempty"`

	// Indicates whether the certificate is in use. This value is `true` if the universe contains a reference to the certificate.
	// Read Only: true
	InUse *bool `json:"inUse,omitempty"`

	// Certificate label
	// Example: yb-admin-example
	Label string `json:"label,omitempty"`

	// Private key path
	// Example: /opt/yugaware/.../example.key.pem
	PrivateKey string `json:"privateKey,omitempty"`

	// The certificate's creation date
	// Format: date-time
	StartDate strfmt.DateTime `json:"startDate,omitempty"`

	// Associated universe details for the certificate
	// Read Only: true
	UniverseDetails []*UniverseDetailSubset `json:"universeDetails"`

	// Certificate UUID
	// Read Only: true
	// Format: uuid
	UUID strfmt.UUID `json:"uuid,omitempty"`
}

// Validate validates this certificate info
func (m *CertificateInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCertType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomCertPathParams(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomHCPKICertInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomServerCertInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomerUUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExpiryDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUniverseDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUUID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var certificateInfoTypeCertTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SelfSigned","CustomCertHostPath","CustomServerCert","HashicorpVault"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		certificateInfoTypeCertTypePropEnum = append(certificateInfoTypeCertTypePropEnum, v)
	}
}

const (

	// CertificateInfoCertTypeSelfSigned captures enum value "SelfSigned"
	CertificateInfoCertTypeSelfSigned string = "SelfSigned"

	// CertificateInfoCertTypeCustomCertHostPath captures enum value "CustomCertHostPath"
	CertificateInfoCertTypeCustomCertHostPath string = "CustomCertHostPath"

	// CertificateInfoCertTypeCustomServerCert captures enum value "CustomServerCert"
	CertificateInfoCertTypeCustomServerCert string = "CustomServerCert"

	// CertificateInfoCertTypeHashicorpVault captures enum value "HashicorpVault"
	CertificateInfoCertTypeHashicorpVault string = "HashicorpVault"
)

// prop value enum
func (m *CertificateInfo) validateCertTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, certificateInfoTypeCertTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CertificateInfo) validateCertType(formats strfmt.Registry) error {
	if swag.IsZero(m.CertType) { // not required
		return nil
	}

	// value enum
	if err := m.validateCertTypeEnum("certType", "body", m.CertType); err != nil {
		return err
	}

	return nil
}

func (m *CertificateInfo) validateCustomCertPathParams(formats strfmt.Registry) error {

	if err := validate.Required("customCertPathParams", "body", m.CustomCertPathParams); err != nil {
		return err
	}

	if m.CustomCertPathParams != nil {
		if err := m.CustomCertPathParams.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("customCertPathParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("customCertPathParams")
			}
			return err
		}
	}

	return nil
}

func (m *CertificateInfo) validateCustomHCPKICertInfo(formats strfmt.Registry) error {

	if err := validate.Required("customHCPKICertInfo", "body", m.CustomHCPKICertInfo); err != nil {
		return err
	}

	if m.CustomHCPKICertInfo != nil {
		if err := m.CustomHCPKICertInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("customHCPKICertInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("customHCPKICertInfo")
			}
			return err
		}
	}

	return nil
}

func (m *CertificateInfo) validateCustomServerCertInfo(formats strfmt.Registry) error {

	if err := validate.Required("customServerCertInfo", "body", m.CustomServerCertInfo); err != nil {
		return err
	}

	if m.CustomServerCertInfo != nil {
		if err := m.CustomServerCertInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("customServerCertInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("customServerCertInfo")
			}
			return err
		}
	}

	return nil
}

func (m *CertificateInfo) validateCustomerUUID(formats strfmt.Registry) error {
	if swag.IsZero(m.CustomerUUID) { // not required
		return nil
	}

	if err := validate.FormatOf("customerUUID", "body", "uuid", m.CustomerUUID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CertificateInfo) validateExpiryDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ExpiryDate) { // not required
		return nil
	}

	if err := validate.FormatOf("expiryDate", "body", "date-time", m.ExpiryDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CertificateInfo) validateStartDate(formats strfmt.Registry) error {
	if swag.IsZero(m.StartDate) { // not required
		return nil
	}

	if err := validate.FormatOf("startDate", "body", "date-time", m.StartDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CertificateInfo) validateUniverseDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.UniverseDetails) { // not required
		return nil
	}

	for i := 0; i < len(m.UniverseDetails); i++ {
		if swag.IsZero(m.UniverseDetails[i]) { // not required
			continue
		}

		if m.UniverseDetails[i] != nil {
			if err := m.UniverseDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("universeDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("universeDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CertificateInfo) validateUUID(formats strfmt.Registry) error {
	if swag.IsZero(m.UUID) { // not required
		return nil
	}

	if err := validate.FormatOf("uuid", "body", "uuid", m.UUID.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this certificate info based on the context it is used
func (m *CertificateInfo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateChecksum(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCustomCertPathParams(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCustomHCPKICertInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCustomServerCertInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInUse(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUniverseDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUUID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CertificateInfo) contextValidateChecksum(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "checksum", "body", string(m.Checksum)); err != nil {
		return err
	}

	return nil
}

func (m *CertificateInfo) contextValidateCustomCertPathParams(ctx context.Context, formats strfmt.Registry) error {

	if m.CustomCertPathParams != nil {
		if err := m.CustomCertPathParams.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("customCertPathParams")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("customCertPathParams")
			}
			return err
		}
	}

	return nil
}

func (m *CertificateInfo) contextValidateCustomHCPKICertInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.CustomHCPKICertInfo != nil {
		if err := m.CustomHCPKICertInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("customHCPKICertInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("customHCPKICertInfo")
			}
			return err
		}
	}

	return nil
}

func (m *CertificateInfo) contextValidateCustomServerCertInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.CustomServerCertInfo != nil {
		if err := m.CustomServerCertInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("customServerCertInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("customServerCertInfo")
			}
			return err
		}
	}

	return nil
}

func (m *CertificateInfo) contextValidateInUse(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "inUse", "body", m.InUse); err != nil {
		return err
	}

	return nil
}

func (m *CertificateInfo) contextValidateUniverseDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "universeDetails", "body", []*UniverseDetailSubset(m.UniverseDetails)); err != nil {
		return err
	}

	for i := 0; i < len(m.UniverseDetails); i++ {

		if m.UniverseDetails[i] != nil {
			if err := m.UniverseDetails[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("universeDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("universeDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CertificateInfo) contextValidateUUID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "uuid", "body", strfmt.UUID(m.UUID)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CertificateInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CertificateInfo) UnmarshalBinary(b []byte) error {
	var res CertificateInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
